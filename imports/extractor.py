from capstone import *
import pandas as pd
import pefile
import os

"""
This module contains the functions to extract features from Portable Executable files.

"""

def start_extraction(root_folder_name, output_file):

    """
    Iterates through the specified root folder and extracts features from each Portable Executable.
    The extracted features is then saved to a CSV in the specified output file.

    """

    # Check if the specified root folder exists
    try:
        folders = os.listdir(root_folder_name)
    except FileNotFoundError:
        print('Root folder not found. Please check the path and try again.')
        return
    
    # Initialize the counters and the dictionary to store the features
    fail_counter = 0
    success_counter = 0
    features_dict = {}
    print('Starting extraction...')

    # Iterate through the folders in the root folder and extract features for each item
    for folder in folders:
        folder_path = os.path.join(root_folder_name, folder)

        # Skip if the item is not a folder
        if not os.path.isdir(folder_path):
            continue

        # Get all the items in the folder
        items = os.listdir(folder_path)

        # Skip if the folder is empty
        if not items:
            continue
        
        # Extract features for each item in the folder
        for item in items:
            item_url = os.path.join(folder_path, item)
            result = extract_features(item_url)
            
            if result is not None:
                features_dict[item] = result
                print('[SUCCESS]', item_url)
                success_counter += 1
            else:
                print('[FAILED]', item_url)
                fail_counter += 1

    # Print the extraction summary once the extraction is completed
    print(f'\nExtraction Completed. {success_counter} successfull, {fail_counter} failed. {round(success_counter / (success_counter + fail_counter) * 100, 2)}% success rate.')

    # Convert the dictionary to a DataFrame and save to a CSV file
    try:
        df = pd.DataFrame.from_dict(features_dict, orient='index')
        df.to_csv(output_file, index=False)
        print(f'Data saved to {output_file}')
        return df
    except Exception as e:
        print('An error occurred while saving the file:', e)



def extract_features(path):

    """
    Extracts features from a Portable Executable file using the pefile library.
 
    """

    # Check if the file is a valid PE file
    try:
        sample = pefile.PE(path)
    except Exception as e:
        return None

    # Define the features dictionary and add the name of the file
    features = {}
    features['Name'] = path.split('\\')[-1]

    # Define the features to extract from the PE file
    attributes = [
        'OPTIONAL_HEADER.CheckSum', 'FILE_HEADER.Machine', 'FILE_HEADER.SizeOfOptionalHeader',
        'FILE_HEADER.Characteristics', 'OPTIONAL_HEADER.MajorLinkerVersion', 'OPTIONAL_HEADER.MinorLinkerVersion',
        'OPTIONAL_HEADER.SizeOfCode', 'OPTIONAL_HEADER.SizeOfInitializedData', 'OPTIONAL_HEADER.SizeOfUninitializedData',
        'OPTIONAL_HEADER.AddressOfEntryPoint', 'OPTIONAL_HEADER.BaseOfCode', 'OPTIONAL_HEADER.BaseOfData',
        'OPTIONAL_HEADER.ImageBase', 'OPTIONAL_HEADER.SectionAlignment', 'OPTIONAL_HEADER.FileAlignment',
        'OPTIONAL_HEADER.MajorOperatingSystemVersion', 'OPTIONAL_HEADER.MinorOperatingSystemVersion',
        'OPTIONAL_HEADER.MajorImageVersion', 'OPTIONAL_HEADER.MinorImageVersion', 'OPTIONAL_HEADER.MajorSubsystemVersion',
        'OPTIONAL_HEADER.MinorSubsystemVersion', 'OPTIONAL_HEADER.SizeOfImage', 'OPTIONAL_HEADER.SizeOfHeaders',
        'OPTIONAL_HEADER.CheckSum', 'OPTIONAL_HEADER.Subsystem', 'OPTIONAL_HEADER.DllCharacteristics',
        'OPTIONAL_HEADER.SizeOfStackReserve', 'OPTIONAL_HEADER.SizeOfStackCommit', 'OPTIONAL_HEADER.SizeOfHeapReserve',
        'OPTIONAL_HEADER.SizeOfHeapCommit', 'OPTIONAL_HEADER.LoaderFlags', 'OPTIONAL_HEADER.NumberOfRvaAndSizes',
        'FILE_HEADER.NumberOfSections'
    ]

    # Add the features to the dictionary
    for attr in attributes:
        parts = attr.split('.')
        obj = sample
        for part in parts:
            if hasattr(obj, part):
                obj = getattr(obj, part)
            else:
                obj = None
                break
        if obj is not None:
            features[attr] = obj
        else:
            features[attr] = 0

    # Extract the entropy, raw size and virtual size of the sections
    MeanEntropy, MaxEntropy, MinEntropy = [], [], []
    MeanRawsize, MaxRawsize, MinRawsize = [], [], []
    MeanVirtualsize, MaxVirtualsize, MinVirtualsize = [], [], []

    for section in sample.sections:
        MeanEntropy.append(section.get_entropy())
        MeanRawsize.append(section.SizeOfRawData)
        MeanVirtualsize.append(section.Misc_VirtualSize)
        MaxEntropy.append(section.get_entropy())
        MaxRawsize.append(section.SizeOfRawData)
        MaxVirtualsize.append(section.Misc_VirtualSize)
        MinEntropy.append(section.get_entropy())
        MinRawsize.append(section.SizeOfRawData)
        MinVirtualsize.append(section.Misc_VirtualSize)

    # Calculate the mean, max and min of the entropy, raw size and virtual size
    try:
        features['MeanEntropy'] = sum(MeanEntropy) / float(len(MeanEntropy))
        features['MaxEntropy'] = max(MaxEntropy)
        features['MinEntropy'] = min(MinEntropy)
    except:
        features['MeanEntropy'] = 0
        features['MaxEntropy'] = 0
        features['MinEntropy'] = 0

    # Calculate the mean, max and min of the raw size
    try:
        features['MeanRawsize'] = sum(MeanRawsize) / float(len(MeanRawsize))
        features['MaxRawsize'] = max(MaxRawsize)
        features['MinRawsize'] = min(MinRawsize)
    except:
        features['MeanRawsize'] = 0
        features['MaxRawsize'] = 0
        features['MinRawsize'] = 0

    # Calculate the mean, max and min of the virtual size
    try:
        features['MeanVirtualsize'] = sum(MeanVirtualsize) / float(len(MeanVirtualsize))
        features['MaxVirtualsize'] = max(MaxVirtualsize)
        features['MinVirtualsize'] = min(MinVirtualsize)
    except:
        features['MeanVirtualsize'] = 0
        features['MaxVirtualsize'] = 0
        features['MinVirtualsize'] = 0

    # Extract the number of imports and the number of DLLs
    try:
        # Extract number of DLLs imported from the PE file
        features['ImportsNbDLL'] = len(sample.DIRECTORY_ENTRY_IMPORT)
        
        # Extract number of imports from each DLL
        import_count = 0
        for entry in sample.DIRECTORY_ENTRY_IMPORT:
            import_count += len(entry.imports)

        features['ImportsNb'] = import_count

        # Extracting the imports names
        imports = []
        for entry in sample.DIRECTORY_ENTRY_IMPORT:
            for imp in entry.imports:
                imports.append(imp.name.decode('utf-8'))

        # Add the imports to the dictionary
        features['DLLImports'] = ' '.join(imports)
    except:
        features['ImportsNbDLL'] = 0
        features['ImportsNb'] = 0
        features['DLLImports'] = ''

    # Extracting the opcodes from the code sections
    try:
        opcodes = []

        # Locate the code sections and extract the opcodes
        for section in sample.sections:
            if section.Characteristics & 0x20:
                code = section.get_data()

                # decode the code and print the disassembled code
                disassembler = Cs(CS_ARCH_X86, CS_MODE_32)
                for instruction in disassembler.disasm(code, section.VirtualAddress):
                    opcodes.append(instruction.mnemonic)

        # Add the opcodes to the dictionary
        features['Opcodes'] = ' '.join(opcodes)
    except:
        features['Opcodes'] = ''
        
    # Add the family name to the dictionary
    features['Family'] = path.split('\\')[-2]
    return features